---
layout: default
---

# SLIC 原理

SLIC--simple linear iterative cluster的简称，该算法用来生成超像素

## 大致思想

算法大致思想是这样的，将图像从RGB颜色空间转换到CIE-Lab颜色空间，对应每个像素的（L，a，b）颜色值和（x，y）坐标组成一个5维向量V[l, a, b, x, y],两个像素的相似性即可由它们的向量距离来度量，距离越大，相似性越小。依据每个像素之间的特征距离，对像素进行聚类，最终形成超像素块。

## 基础K-Means之简介

K-means算法是硬聚类算法，是典型的基于原型的目标函数聚类方法的代表，它是数据点到原型的某种距离作为优化的目标函数，利用函数求极值的方法得到迭代运算的调整规则。K-means算法以欧式距离作为相似度测度，它是求对应某一初始聚类中心向量V最优分类，使得评价指标J最小。算法采用误差平方和准则函数作为聚类准则函数。

算法过程如下：

1. 从N个文档随机选取K个文档作为质心
2. 对剩余的每个文档测量其到每个质心的距离，并把它归到最近的质心的类
3. 重新计算已经得到的各个类的质心
4. 迭代2～3步直至新的质心与原质心相等或小于指定阈值，算法结束
<p style="text-align:center">
<img src="https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike72%2C5%2C5%2C72%2C24/sign=3c30395bf2d3572c72ef948eeb7a0842/9c16fdfaaf51f3de826ed7d694eef01f3b2979a7.jpg" style="width:50%">
</p>

具体如下：

\#. 输入：k, data[n];
1. 选择k个初始中心点，例如c[0]=data[0],…c[k-1]=data[k-1]；
2. 对于data[0]….data[n]，分别与c[0]…c[k-1]比较，假定与c[i]差值最少，就标记为i；
3. 对于所有标记为i点，重新计算c[i]={ 所有标记为i的data[j]之和}/标记为i的个数；
4. 重复(2)(3)，直到所有c[i]值的变化小于给定阈值。

## 基于K-Mean聚类之上的SLIC算法

### SLIC算法步骤：

第一步：均匀撒种子。将K个超像素中心分布到M\*N图像的像素点上。每个种子负责大约$S = M*N/K$的面积。

第二步：微调种子的位置。以每个像素点为中心的3×3范围内，移动超像素中心到这9个点中梯度最小的点上。这样是为了避免超像素点落到噪点或者边界上。

第三步：对每一个超像素中心x，它$2S$范围内的点：计算基于$[L,a,b,x,y]^T$的特征距离，将每个像素点归类于离他最近的种子内。

具体每一步中算法的原因性，参考[http://www.cnblogs.com/supersponge/p/6546082.html](http://www.cnblogs.com/supersponge/p/6546082.html)

![eq1](/assets/file/20180329/eq1.png)
<img src="/assets/file/20180329/eq2.png" style="width:50%">





### 自己进行的SLIC算法改进：加深度信息的SLIC

在原来$[L,a,b,x,y]^T$的基础上，加入深度信息D,并给与一个新的权重：
![eq3](/assets/file/20180329/eq3.png)

效果：
![img](/assets/file/20180329/img.jpg)

然后带不带深度，区别还挺大的，尤其是我昨天说到的那个颜色相近，但是前后物体交叠的部分。（详见鲨鱼的鼻子。。）

[Back](../../../index)
